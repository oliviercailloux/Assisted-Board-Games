= TODO
:o: pass:normal[+[{nbsp}]+]
:c: pass:normal[+[&#10004;]+]


Currently, we have a game of Chess and a game of Checkers, but they are quite brittle. We will consolidate those so as to be able to then make them more generic. We will also design better clients (in Javascript), and strive to make them generic as well. We will start by moving the server core to Quarkus, a more modern server architecture in Java.

. {c} Move model file to `Doc/Papyrus/Model.di` (and related ones similarly)
. {c} In the main Doc document, start with a link to the currently existing complete Use case diagram.
. {c} Create a new UC diagram with only the `Play chess` UC (rename the current one) and `Play new chess game` that inherits from it. Export it as https://github.com/oliviercailloux/UML/blob/main/Papyrus/Various.adoc#graphics-format[SVG] into `Doc/Papyrus/Diagrams`. Integrate it into your main doc and explain briefly that this will be our main focus to start with; and specify that this means that the game must be recorded on the server. Use `System` as a subject, not `PlayerPlaysGame` (rename the current one).
. {c} Create a UC, exported in another diagram: `Record chess move graphically`, in subject `GUI`. It interacts with both the `Player` (change case of current one) and the `Server` (an actor that should be displayed as a classifier). The `Play chess` UC uses this one. Explain in the doc that this is required for the other one so that it must be done first.
. {c} Create a UC, exported in another diagram: `Record chess move`, in subject `UI`. It interacts with the same actors as the graphical one. Explain in the doc that this will be our short term main focus.
. {c} Make sure that all the current documentation can be reached by following links from the main documentation page. Use https://github.com/oliviercailloux/J-Voting/tree/master/Doc[J-Voting doc] as an example.
. {c} Move diagrams into `Doc/Papyrus/Diagrams`, transform to SVG, delete the ones that are not referenced.
. {c} In a new branch `quarkus`, delete everything. Replace by this https://github.com/oliviercailloux/Sample-Quarkus-Heroku/[sample].
. {c} Create a Heroku account and deploy your server there, without using Herkou command line tools but using only Heroku web GUI. Write an Asciidoc file that explains how to do this, including how to test that everything went well.
. {c} Write a documentation that explains how one can test that the server works by using curl (see doc in this course, adapt it to your case).
. Add a simple class to reproduce a very basic functionality of your server. Make sure you can contact it with curl and write a doc to explain how to check this. Consider translating and adapting my original documentation.
. Re-import everything piece by piece into the new canvas so as to rebuild the existing functionality.
. Make sure the js files are accessible once the server runs on Heroku. (Explain in the doc, if this creates some difficulties.)
. Design Javascript classes that are able to send the moves that are played to the server and restore games at previous points. For the chess game.
. Design generic Javascript classes that permit one to describe a move in Json and send it to the server (so that we move towards generic files that work with any game, though the goal of this task is just to make this work with chess).
. Propose a plan so that the server accepts similar instructions for the Checkers game, so that the same Javascript classes (the ones from the previous task) can be used.
. Create a class diagram on Papyrus about the `Game Management` and update its references on the documentation.
. Make the corrections asked about the structure on the `README` documentation :
- The link towards `https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/main/Doc/Game_management_Documentation.adoc[Game_Management]` documentation does not exist.
- Export the `Game Management` diagram as SVG and display it directly instead of a link.
- For the structure : Start with the description, then the `Game management` diagram and then the details.
. Centralize and index the documentation into the right directories (which was not necessarily done in the old version of the project).
. Create a summary within the `https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/main/Doc/README.adoc[README]` including the links to the existing documentation

. Complete the translation of the `original documentation` and the `original description` in the existing `https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/main/Doc/README.adoc[documentation]`.
. Create a class diagram and a UC diagram related to the `original description`.
. Write a documentation that explains how the server of the latest version of the project works. Create a class diagram that also explains how the server works.
. Update the `https://github.com/oliviercailloux-org/projet-assisted-board-games-1/blob/main/README.adoc[Global README]` for the `local configuration file`.
. Move the entity `MoveEntity` from the latest jetty version to the new quarkus version. Check if everything works on the new version and if its creates the table.
. Move the entity `Game entity` from the latest jetty version to the new quarkus version and check if everything works
. Move the entity `ChessBoard` from the latest jetty version to the new quarkus version and check if everything works
. Create the repository "state" in the repository "model" and move the classes `GameState`and `PlayerState` from the latest jetty version to the new quarkus version and check if everything works 
. Move the classes `GameDAO`and `MoveDAO` from the latest jetty version to the new quarkus version and check if everything works
. Move the repository "utils" and its classes, no modifation is needed. 
. Create the repository "service" and move the class "ChessService" from the latest jetty version to the new quarkus version and check if everything works.
. Create the repository "ressource" and move the class "GameRessource" from the latest jetty version to the new quarkus version and check if everything works.


== Original specifications (to be translated and adapted)
* Les clients individuels des joueurs leur permettront de jouer en recevant l’assistance d’un ordinateur : le joueur peut de façon privée (sans le montrer à son adversaire) proposer un coup, et l’ordinateur lui montrera les meilleurs réponses à son coup. En limitant adéquatement la profondeur de recherche de l’ordinateur, cela pourrait permettre aux joueurs d’éviter les erreurs basiques, ou fournir un avantage compensatoire à un joueur plus faible, ou aider à l’apprentissage. (Pour commencer on choisira n’importe quelle façon simple de trouver des coups valables, à terme il serait bon d’utiliser une bibliothèque existante de recherche de bons coups)
* Autres aides : liste de bons coups possibles pour le prochain coup, stratégie menant à la victoire ou à une meilleure position (sous forme de meilleurs coups de part et d’autre), stratégie sous forme d’arbre de profondeur et largeur donnés.
* Séparer ce qui est propre au jeu d’échec (en gros, dans le package `io.github.oliviercailloux.assisted_board_games.model`) de la partie serveur (en gros, le reste), en vue de la généralisation à d’autres jeux. Envisager de fournir à `GameResources` une interface qui offre les services spécifiques au jeu pour lequel un serveur est demandé.
* Généraliser autant que possible pour faciliter l’implémentation d’un nouveau jeu (tel que les dames). Par exemple, la logique de comptage du temps n’est pas spécifique aux échecs et devrait pouvoir être réutilisée.
* Implémenter un nouveau jeu dans un autre sous-package (par exemple `checkers`). Ceci ne devrait pas induire de redondance avec le jeu existant.
* Prévoir une interface rudimentaire et générique pour ce nouveau jeu, sous forme d’affichage de l’état de la partie en JSON et envoi des nouveaux coups en JSON (donc sans graphisme)
* En plus de l’interface générique rudimentaire, envisager une interface spécifique au jeu de dames (similaire à celle utilisée pour les échecs)
* Implémenter un jeu (t.q. pierre, feuille, ciseaux) avec concept d’état partiellement caché : état complet (inclut données pour tous les joueurs, par ex. : joueur 1 a choisi _pierre_, joueur 2 n’a pas encore choisi) ; état partiel, visible par un joueur donné (par ex., le joueur 2 voit : joueur 1 a choisi, joueur 2 doit encore choisir) ; état visible, sous-ensemble des données visibles par tous (ce que voit un spectateur qui ne connait pas l’information propre aux joueurs). Dans le cas où tout est visible (par ex. les échecs), les trois états sont égaux.
* Implémenter un jeu (t.q. jeu de l’oie) avec hasard : l’état complet inclut un générateur déterministe qui contient toutes les possibilités, auquel on demande tout tirage aléatoire. Ce générateur doit être enregistré avec la partie, et n’est pas visible.
* Implémenter un jeu (t.q. Texas Hold’em) avec état partiellement caché et hasard.

== Autres idées
* Permettre un fork de partie à un certain coup (bonus : permettre d’enregistrer une série de générateurs avec une partie, associés à un numéro de coup, pour permettre de changer le générateur lors du fork) ; de nommer la partie (exemple : partie célèbre Kasparov contre Deep Blue), de trouver les états communs…
* Analyser le langages de description de http://www.zillions-of-games.com/[Zillion of Games] ou d’autres aspects de ce service et rédiger un rapport en Asciidoctor indiquant ce qui peut être utilisé dans le projet.
